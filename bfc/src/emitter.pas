unit emitter;

interface

const
  EMITTER_WIN32 = 1;
  EMITTER_LINUX = 2;

procedure emitter_init(fname : string);
procedure emitter_done;

procedure emitter_start;
procedure emitter_end;
procedure emitter_set_target(n : integer);
procedure emitter_inc(n : integer);
procedure emitter_dec(n : integer);
procedure emitter_add(n : integer);
procedure emitter_sub(n : integer);
procedure emitter_push_data;
procedure emitter_push_data_ptr;
procedure emitter_call(s : string);
procedure emitter_while_begin(n : integer);
procedure emitter_while_end(n : integer);

implementation

uses bfcutil;

var
  fout : text;
  target : integer;
  bf_data_size : integer;
  bf_stack_size : integer;


procedure emitter_start_win32;
begin
  WriteLn(fout, '; Generated by BFC (Brainfuck 32-Bit Compiler)');
  WriteLn(fout);
{   emit_program;}
  WriteLn(fout, 'EXTERN bf_init');
  WriteLn(fout, 'EXTERN bf_print');
  WriteLn(fout, 'EXTERN bf_exit');
  WriteLn(fout, 'EXTERN bf_read');
  WriteLn(fout, 'EXTERN _end');
  WriteLn(fout);
  WriteLn(fout, 'SEGMENT .text USE32');
  WriteLn(fout, '   GLOBAL _start');
  WriteLn(fout, '_start:');
{  WriteLn(fout, '   mov   eax, stack_end');
  WriteLn(fout, '   mov   esp, eax');}
{  WriteLn(fout, '   sub   eax, ', bf_data_size+bf_stack_size);}
  WriteLn(fout, '   mov   ebp, data_start');
  WriteLn(fout, '   call  bf_init');
  WriteLn(fout);
  WriteLn(fout, 'clear:');
  WriteLn(fout, '   mov   edi, ebp');
  WriteLn(fout, '   add   edi, ', bf_data_size);
  WriteLn(fout, '   mov   ecx, ', bf_data_size div 4);
  WriteLn(fout, '   xor   eax, eax');
  WriteLn(fout, '   std');
  WriteLn(fout, '   rep stosd');
  WriteLn(fout);
  WriteLn(fout, 'main:');
end;

procedure emitter_start_linux;
begin
  WriteLn(fout, '// Generated by BFC (Brainfuck 32-Bit Compiler)');
  WriteLn(fout);
{   emit_program;}
  WriteLn(fout, '.extern bf_init');
  WriteLn(fout, '.extern bf_print');
  WriteLn(fout, '.extern bf_exit');
  WriteLn(fout, '.extern bf_read');
  WriteLn(fout, '.extern _end');
  WriteLn(fout);
  WriteLn(fout, '.text');
  WriteLn(fout, '   .globl _start');
  WriteLn(fout, '_start:');
{  WriteLn(fout, '   movl  stack_end, %eax');
  WriteLn(fout, '   movl  %eax, %esp');}
{  WriteLn(fout, '   sub   eax, ', bf_data_size+bf_stack_size);}
  WriteLn(fout, '   call  bf_init');
  WriteLn(fout);
  WriteLn(fout, '   movl  $DATA, %ebp');
  WriteLn(fout, 'clear:');
  WriteLn(fout, '   movl  %ebp, %edi');
  WriteLn(fout, '   addl  $', bf_data_size, ', %edi');
  WriteLn(fout, '   movl  $', bf_data_size div 4, ', %ecx');
  WriteLn(fout, '   xorl  %eax, %eax');
  WriteLn(fout, '   std');
  WriteLn(fout, '   rep; stosl');
  WriteLn(fout);
  WriteLn(fout, 'main:');end;

procedure emitter_start;
begin
	case target of
		EMITTER_WIN32: emitter_start_win32;
		EMITTER_LINUX: emitter_start_linux;
	end;
end;



procedure emitter_end_win32;
begin
  WriteLn(fout);
  WriteLn(fout, '   call  bf_exit');
  WriteLn(fout);
  WriteLn(fout, 'SEGMENT .bss USE32');
	WriteLn(fout, 'GLOBAL data_start');
	WriteLn(fout, 'data_start:');
  WriteLn(fout, '   resd  ', bf_data_size div 4);
  WriteLn(fout, 'stack:');
  WriteLn(fout, '   resb  ', bf_stack_size);
  WriteLn(fout, 'stack_end:');
  Writeln(fout);
  WriteLn(fout, '; *** End Of File ***');
end;

procedure emitter_end_linux;
begin
  WriteLn(fout);
  WriteLn(fout, '   call  bf_exit');
  WriteLn(fout);
  WriteLn(fout, '.bss');
  WriteLn(fout, '   .comm DATA, ', bf_data_size);
{  WriteLn(fout, 'stack:');
  WriteLn(fout, '   .comm STACK, ', bf_stack_size);
  WriteLn(fout, 'stack_end:');}
  Writeln(fout);
  WriteLn(fout, '// *** End Of File ***');
end;

procedure emitter_end;
begin
	case target of
		EMITTER_WIN32: emitter_end_win32;
		EMITTER_LINUX: emitter_end_linux;
	end;
end;



procedure emitter_set_target(n : integer);
begin
	target := n;
end;



procedure emitter_inc_linux(n : integer);
begin
  if n = 1 then WriteLn(fout, '   incl  %ebp')
  else WriteLn(fout, '   addl  $',n,', %ebp');
end;

procedure emitter_inc_win32(n : integer);
begin
  if n = 1 then WriteLn(fout, '   inc   ebp')
  else WriteLn(fout, '   add   ebp, ', n);
end;

procedure emitter_inc(n : integer);
begin
	case target of
		EMITTER_WIN32: emitter_inc_win32(n);
		EMITTER_LINUX: emitter_inc_linux(n);
	end;
end;



procedure emitter_dec_linux(n : integer);
begin
  if n = 1 then WriteLn(fout, '   decl  %ebp')
  else WriteLn(fout, '   subl   $',n,', %ebp');
end;

procedure emitter_dec_win32(n : integer);
begin
  if n = 1 then WriteLn(fout, '   dec   ebp')
  else WriteLn(fout, '   sub   ebp, ', n);
end;

procedure emitter_dec(n : integer);
begin
	case target of
		EMITTER_WIN32: emitter_dec_win32(n);
		EMITTER_LINUX: emitter_dec_linux(n);
	end;
end;



procedure emitter_add_win32(n : integer);
begin
  if n = 1 then WriteLn(fout, '   inc   byte [ebp]')
  else WriteLn(fout, '   add   byte [ebp], ', n);
end;

procedure emitter_add_linux(n : integer);
begin
  if n = 1 then WriteLn(fout, '   incb  (%ebp)')
  else WriteLn(fout, '   addb  $',n,', (%ebp)');
end;

procedure emitter_add(n : integer);
begin
	case target of
		EMITTER_WIN32: emitter_add_win32(n);
		EMITTER_LINUX: emitter_add_linux(n);
	end;
end;



procedure emitter_sub_win32(n : integer);
begin
  if n = 1 then WriteLn(fout, '   dec   byte [ebp]')
  else WriteLn(fout, '   sub   byte [ebp], ', n);
end;

procedure emitter_sub_linux(n : integer);
begin
  if n = 1 then WriteLn(fout, '   decb  (%ebp)')
  else WriteLn(fout, '   subb  $',n,', (%ebp)');
end;

procedure emitter_sub(n : integer);
begin
	case target of
		EMITTER_WIN32: emitter_sub_win32(n);
		EMITTER_LINUX: emitter_sub_linux(n);
	end;
end;



procedure emitter_call(s : string);
begin
  WriteLn(fout, '   call  ', s);
end;



procedure emitter_while_begin_win32(n : integer);
begin
  WriteLn(fout, '.L', n, ':');
  WriteLn(fout, '   cmp   byte [ebp], 0');
  WriteLn(fout, '   jnz   .LC', n);
  WriteLn(fout, '   jmp   .LE', n);
  WriteLn(fout, '.LC', n, ':');
end;

procedure emitter_while_begin_linux(n : integer);
begin
  WriteLn(fout, 'L', n, ':');
  WriteLn(fout, '   cmpb  $0, (%ebp)');
  WriteLn(fout, '   jnz   LC', n);
  WriteLn(fout, '   jmp   LE', n);
  WriteLn(fout, 'LC', n, ':');
end;

procedure emitter_while_begin(n : integer);
begin
	case target of
		EMITTER_WIN32: emitter_while_begin_win32(n);
		EMITTER_LINUX: emitter_while_begin_linux(n);
	end;
end;



procedure emitter_while_end_win32(n : integer);
begin
  WriteLn(fout, '   jmp   .L', n);
  WriteLn(fout, '.LE', n, ':');
  WriteLn(fout);
end;

procedure emitter_while_end_linux(n : integer);
begin
  WriteLn(fout, '   jmp   L', n);
  WriteLn(fout, 'LE', n, ':');
  WriteLn(fout);
end;

procedure emitter_while_end(n : integer);
begin
	case target of
		EMITTER_WIN32: emitter_while_end_win32(n);
		EMITTER_LINUX: emitter_while_end_linux(n);
	end;
end;




procedure emitter_push_data_win32;
begin
	WriteLn(fout, '   mov   eax, [ebp]');
	WriteLn(fout, '   push  eax');
end;

procedure emitter_push_data_linux;
begin
	WriteLn(fout, '   movl  (%ebp), %eax');
	WriteLn(fout, '   pushl %eax');
end;

procedure emitter_push_data;
begin
	case target of
		EMITTER_WIN32: emitter_push_data_win32;
		EMITTER_LINUX: emitter_push_data_linux;
	end;
end;



procedure emitter_push_data_ptr_win32;
begin
	WriteLn(fout, '   push  ebp');
end;

procedure emitter_push_data_ptr_linux;
begin
	WriteLn(fout, '   pushl %ebp');
end;

procedure emitter_push_data_ptr;
begin
	case target of
		EMITTER_WIN32: emitter_push_data_ptr_win32;
		EMITTER_LINUX: emitter_push_data_ptr_linux;
	end;
end;

procedure emitter_init(fname : string);
begin
  bf_data_size := 30000;
  bf_stack_size := 16000;

  bf_data_size := bf_data_size div 4;
  bf_data_size := bf_data_size * 4;

  {$IFDEF LINUX}
    assign(fout, get_filename(fname)+'.s');
  {$ELSE}
    assign(fout, get_filename(fname)+'.asm');
  {$ENDIF}
  
  rewrite(fout);
end;

procedure emitter_done;
begin
  close(fout);
end;

begin
  target := EMITTER_WIN32;
end.
