unit emitter;

interface

const
  EMITTER_WIN32 = 1;
  EMITTER_LINUX_I386 = 2;
  EMITTER_C = 3;
  
procedure emitter_init(fname : string);
procedure emitter_done;

procedure emitter_start;
procedure emitter_end;
procedure emitter_set_target(n : integer);
procedure emitter_inc(n : integer);
procedure emitter_dec(n : integer);
procedure emitter_add(n : integer);
procedure emitter_sub(n : integer);
procedure emitter_push_data;
procedure emitter_push_data_ptr;
procedure emitter_call(s : string);
procedure emitter_while_begin(n : integer);
procedure emitter_while_end(n : integer);

implementation

uses bfcutil;

var
  fout : text;
  target : integer;
  bf_data_size : integer;
  bf_stack_size : integer;


procedure emitter_start_win32;
begin
  WriteLn(fout, '; Generated by BFC (Brainfuck 32-Bit Compiler)');
  WriteLn(fout);
{   emit_program;}
  WriteLn(fout, 'EXTERN bf_init');
  WriteLn(fout, 'EXTERN bf_print');
  WriteLn(fout, 'EXTERN bf_exit');
  WriteLn(fout, 'EXTERN bf_read');
  WriteLn(fout, 'EXTERN _end');
  WriteLn(fout);
  WriteLn(fout, 'SEGMENT .text USE32');
  WriteLn(fout, '   GLOBAL _start');
  WriteLn(fout, '_start:');
{  WriteLn(fout, '   mov   eax, stack_end');
  WriteLn(fout, '   mov   esp, eax');}
{  WriteLn(fout, '   sub   eax, ', bf_data_size+bf_stack_size);}
  WriteLn(fout, '   mov   ebp, data_start');
  WriteLn(fout, '   call  bf_init');
  WriteLn(fout);
  WriteLn(fout, 'clear:');
  WriteLn(fout, '   mov   edi, ebp');
  WriteLn(fout, '   add   edi, ', bf_data_size);
  WriteLn(fout, '   mov   ecx, ', bf_data_size div 4);
  WriteLn(fout, '   xor   eax, eax');
  WriteLn(fout, '   std');
  WriteLn(fout, '   rep stosd');
  WriteLn(fout);
  WriteLn(fout, 'main:');
end;

procedure emitter_start_linux;
begin
  WriteLn(fout, '// Generated by BFC (Brainfuck 32-Bit Compiler)');
  WriteLn(fout);
{   emit_program;}
  WriteLn(fout, '.extern bf_init');
  WriteLn(fout, '.extern bf_print');
  WriteLn(fout, '.extern bf_exit');
  WriteLn(fout, '.extern bf_read');
  WriteLn(fout, '.extern _end');
  WriteLn(fout);
  WriteLn(fout, '.text');
  WriteLn(fout, '   .globl _start');
  WriteLn(fout, '_start:');
{  WriteLn(fout, '   movl  stack_end, %eax');
  WriteLn(fout, '   movl  %eax, %esp');}
{  WriteLn(fout, '   sub   eax, ', bf_data_size+bf_stack_size);}
  WriteLn(fout, '   call  bf_init');
  WriteLn(fout);
  WriteLn(fout, '   movl  $data, %ebp');
  WriteLn(fout, 'clear:');
  WriteLn(fout, '   movl  %ebp, %edi');
{  WriteLn(fout, '   addl  $', bf_data_size, ', %edi');}
  WriteLn(fout, '   movl  $', bf_data_size div 4, ', %ecx');
  WriteLn(fout, '   xorl  %eax, %eax');
{  WriteLn(fout, '   inc   %eax');}
  WriteLn(fout, '   cld');
  WriteLn(fout, '   rep; stosl');
  WriteLn(fout);
  WriteLn(fout, 'main:');end;

procedure emitter_start_c;
begin
   WriteLn(fout, '/* Generated by BeBFC Brainf*** Compiler */');
   WriteLn(fout);
   WriteLn(fout, '#include <stdio.h>');
   WriteLn(fout);
   WriteLn(fout, 'unsigned char data[',bf_data_size,'];');
   WriteLn(fout, 'unsigned char *p=data;');
   WriteLn(fout, 'int i;');
   WriteLn(fout, '');
   WriteLn(fout, 'void bf_init() {}');
   WriteLn(fout, '');
   WriteLn(fout, 'void bf_print()');
   WriteLn(fout, '{');
   WriteLn(fout, '   putc(*p, stdout);');
   WriteLn(fout, '   fflush(stdout);');
   WriteLn(fout, '}');
   WriteLn(fout, '');
   WriteLn(fout, 'void bf_read()');
   WriteLn(fout, '{');
   WriteLn(fout, '   *p=getc(stdin);');
   WriteLn(fout, '}');
   WriteLn(fout, '');
   WriteLn(fout, 'void bf_exit() {}');
   WriteLn(fout, '');
   WriteLn(fout, '');
   WriteLn(fout, 'int main(void)');
   WriteLn(fout, '{');
   WriteLn(fout);
   WriteLn(fout, '   for(i=0; i<',bf_data_size,'; i++) data[i] = 0;');
   WriteLn(fout);
end;

procedure emitter_start;
begin
	case target of
		EMITTER_WIN32: emitter_start_win32;
		EMITTER_LINUX_I386: emitter_start_linux;
      EMITTER_C    : emitter_start_c;
	end;
end;



procedure emitter_end_win32;
begin
  WriteLn(fout);
  WriteLn(fout, '   call  bf_exit');
  WriteLn(fout);
  WriteLn(fout, 'SEGMENT .bss USE32');
	WriteLn(fout, 'GLOBAL data_start');
	WriteLn(fout, 'data_start:');
  WriteLn(fout, '   resd  ', bf_data_size div 4);
  WriteLn(fout, 'stack:');
  WriteLn(fout, '   resb  ', bf_stack_size);
  WriteLn(fout, 'stack_end:');
  Writeln(fout);
  WriteLn(fout, '; *** End Of File ***');
end;

procedure emitter_end_linux;
begin
  WriteLn(fout);
  WriteLn(fout, '   call  bf_exit');
  WriteLn(fout);
  WriteLn(fout, '.data');
  WriteLn(fout, '.globl data_size');
  WriteLn(fout, 'data_size:');
  WriteLn(fout, '   .int ', bf_data_size);
  WriteLn(fout);
  WriteLn(fout, '.bss');
  WriteLn(fout, '   .comm data, ', bf_data_size);
{  WriteLn(fout, 'stack:');
  WriteLn(fout, '   .comm STACK, ', bf_stack_size);
  WriteLn(fout, 'stack_end:');}
  Writeln(fout);
  WriteLn(fout, '// *** End Of File ***');
end;

procedure emitter_end_c;
begin
   WriteLn(fout, '   return(0);');
   WriteLn(fout, '}');
end;

procedure emitter_end;
begin
	case target of
		EMITTER_WIN32: emitter_end_win32;
		EMITTER_LINUX_I386: emitter_end_linux;
      EMITTER_C    : emitter_end_c;
	end;
end;



procedure emitter_set_target(n : integer);
begin
	target := n;
end;



procedure emitter_inc_linux(n : integer);
begin
  if n = 1 then WriteLn(fout, '   incl  %ebp')
  else WriteLn(fout, '   addl  $',n,', %ebp');
end;

procedure emitter_inc_win32(n : integer);
begin
  if n = 1 then WriteLn(fout, '   inc   ebp')
  else WriteLn(fout, '   add   ebp, ', n);
end;

procedure emitter_inc_c(n : integer);
begin
   WriteLn(fout, '   p+=',n,';');
end;

procedure emitter_inc(n : integer);
begin
	case target of
		EMITTER_WIN32: emitter_inc_win32(n);
		EMITTER_LINUX_I386: emitter_inc_linux(n);
      EMITTER_C : emitter_inc_c(n);
	end;
end;



procedure emitter_dec_linux(n : integer);
begin
  if n = 1 then WriteLn(fout, '   decl  %ebp')
  else WriteLn(fout, '   subl  $',n,', %ebp');
end;

procedure emitter_dec_win32(n : integer);
begin
  if n = 1 then WriteLn(fout, '   dec   ebp')
  else WriteLn(fout, '   sub   ebp, ', n);
end;

procedure emitter_dec_c(n : integer);
begin
  WriteLn(fout, '   p-=',n,';');
end;

procedure emitter_dec(n : integer);
begin
	case target of
		EMITTER_WIN32: emitter_dec_win32(n);
		EMITTER_LINUX_I386: emitter_dec_linux(n);
      EMITTER_C: emitter_dec_c(n);
	end;
end;



procedure emitter_add_win32(n : integer);
begin
  if n = 1 then WriteLn(fout, '   inc   byte [ebp]')
  else WriteLn(fout, '   add   byte [ebp], ', n);
end;

procedure emitter_add_linux(n : integer);
begin
  if n = 1 then WriteLn(fout, '   incb  (%ebp)')
  else WriteLn(fout, '   addb  $',n,', (%ebp)');
end;

procedure emitter_add_c(n : integer);
begin
  WriteLn(fout, '   *p+=',n,';');
end;

procedure emitter_add(n : integer);
begin
	case target of
		EMITTER_WIN32: emitter_add_win32(n);
		EMITTER_LINUX_I386: emitter_add_linux(n);
      EMITTER_C: emitter_add_c(n);
	end;
end;



procedure emitter_sub_win32(n : integer);
begin
  if n = 1 then WriteLn(fout, '   dec   byte [ebp]')
  else WriteLn(fout, '   sub   byte [ebp], ', n);
end;

procedure emitter_sub_linux(n : integer);
begin
  if n = 1 then WriteLn(fout, '   decb  (%ebp)')
  else WriteLn(fout, '   subb  $',n,', (%ebp)');
end;

procedure emitter_sub_c(n : integer);
begin
  WriteLn(fout, '   *p-=',n,';');
end;

procedure emitter_sub(n : integer);
begin
	case target of
		EMITTER_WIN32: emitter_sub_win32(n);
		EMITTER_LINUX_I386: emitter_sub_linux(n);
      EMITTER_C: emitter_sub_c(n);
	end;
end;



procedure emitter_call_asm(s : string);
begin
  WriteLn(fout, '   call  ', s);
end;

procedure emitter_call_c(s : string);
begin
  WriteLn(fout, '   ',s,'();');
end;

procedure emitter_call(s : string);
begin
  case target of
    EMITTER_WIN32: emitter_call_asm(s);
    EMITTER_LINUX_I386: emitter_call_asm(s);
    EMITTER_C: emitter_call_c(s);
  end;
end;


procedure emitter_while_begin_win32(n : integer);
begin
  WriteLn(fout, '.L', n, ':');
  WriteLn(fout, '   cmp   byte [ebp], 0');
  WriteLn(fout, '   jnz   .LC', n);
  WriteLn(fout, '   jmp   .LE', n);
  WriteLn(fout, '.LC', n, ':');
end;

procedure emitter_while_begin_linux(n : integer);
begin
  WriteLn(fout, 'L', n, ':');
  WriteLn(fout, '   cmpb  $0, (%ebp)');
  WriteLn(fout, '   jnz   LC', n);
  WriteLn(fout, '   jmp   LE', n);
  WriteLn(fout, 'LC', n, ':');
end;

procedure emitter_while_begin_c(n : integer);
begin
  WriteLn(fout, '   while(*p > 0) {');
end;

procedure emitter_while_begin(n : integer);
begin
	case target of
		EMITTER_WIN32: emitter_while_begin_win32(n);
		EMITTER_LINUX_I386: emitter_while_begin_linux(n);
      EMITTER_C: emitter_while_begin_c(n);
	end;
end;



procedure emitter_while_end_win32(n : integer);
begin
  WriteLn(fout, '   jmp   .L', n);
  WriteLn(fout, '.LE', n, ':');
  WriteLn(fout);
end;

procedure emitter_while_end_linux(n : integer);
begin
  WriteLn(fout, '   jmp   L', n);
  WriteLn(fout, 'LE', n, ':');
  WriteLn(fout);
end;

procedure emitter_while_end_c(n : integer);
begin
  WriteLn(fout, '   }');
end;

procedure emitter_while_end(n : integer);
begin
	case target of
		EMITTER_WIN32: emitter_while_end_win32(n);
		EMITTER_LINUX_I386: emitter_while_end_linux(n);
      EMITTER_C: emitter_while_end_c(n);
	end;
end;




procedure emitter_push_data_win32;
begin
	WriteLn(fout, '   mov   eax, [ebp]');
	WriteLn(fout, '   push  eax');
end;

procedure emitter_push_data_linux;
begin
	WriteLn(fout, '   movl  (%ebp), %eax');
	WriteLn(fout, '   pushl %eax');
end;

procedure emitter_push_data_c;
begin
end;

procedure emitter_push_data;
begin
	case target of
		EMITTER_WIN32: emitter_push_data_win32;
		EMITTER_LINUX_I386: emitter_push_data_linux;
      EMITTER_C: emitter_push_data_c;
	end;
end;



procedure emitter_push_data_ptr_win32;
begin
	WriteLn(fout, '   push  ebp');
end;

procedure emitter_push_data_ptr_linux;
begin
	WriteLn(fout, '   pushl %ebp');
end;

procedure emitter_push_data_ptr_c;
begin
end;

procedure emitter_push_data_ptr;
begin
	case target of
		EMITTER_WIN32: emitter_push_data_ptr_win32;
		EMITTER_LINUX_I386: emitter_push_data_ptr_linux;
      EMITTER_C: emitter_push_data_ptr_c;
	end;
end;

procedure emitter_init(fname : string);
var
  suffix : string[4];
begin
  bf_data_size := 30000;
  bf_stack_size := 16000;

  bf_data_size := bf_data_size div 4;
  bf_data_size := bf_data_size * 4;

  suffix := '.c';
  
  case target of
    EMITTER_C: suffix := '.c';
    EMITTER_LINUX_I386: suffix := '.s';
    EMITTER_WIN32: suffix := '.asm';
  end;
 
  assign(fout, get_filename(fname)+suffix);
  
  rewrite(fout);
end;

procedure emitter_done;
begin
  close(fout);
end;

begin
  target := EMITTER_C;
  {$IFDEF LINUX}
    target := EMITTER_LINUX_I386;
  {$ENDIF}
  {$IFDEF WIN32}
    target := EMITTER_WIN32;
  {$ENDIF}
end.
